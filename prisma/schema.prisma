generator client {
  provider = "prisma-client"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

enum UserRole {
  admin
  user
}

model Song {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  title     String
  artist    String?
  album     String?
  albumArtist String?
  trackNumber Int?
  discNumber Int?
  year      Int?
  genre     String?
  isrc      String?
  lyrics    String?
  rating    Int?
  starredAt DateTime?
  playCount Int      @default(0)
  lastPlayedAt DateTime?
  bitrate   Int?
  sampleRate Int?
  channels  Int?
  replayGainTrackDb   Float?
  replayGainAlbumDb   Float?
  replayGainTrackPeak Float?
  replayGainAlbumPeak Float?
  duration  Int?
  format    String
  quality   String?
  source    String
  sourceUrl String?
  filePath  String
  relativePath String?
  fileMtime DateTime?
  fileHash  String?
  coverPath String?
  thumbnail String?
  fileSize  Int?
  artistId  Int?
  artistRef Artist?  @relation(fields: [artistId], references: [id], onDelete: SetNull)
  albumId   Int?
  albumRef  Album?   @relation(fields: [albumId], references: [id], onDelete: SetNull)
  libraryId Int?
  library   Library? @relation(fields: [libraryId], references: [id], onDelete: SetNull)
  playlistId Int?
  playlist   Playlist? @relation(fields: [playlistId], references: [id], onDelete: SetNull)
  downloadTaskId Int?
  downloadTask DownloadTask? @relation(fields: [downloadTaskId], references: [id], onDelete: SetNull)
  playbackSessionsCurrent PlaybackSession[] @relation("CurrentPlaybackSong")
  playbackQueueItems PlaybackQueueItem[] @relation("QueueSong")
  bookmarks Bookmark[]
  sharedEntries ShareEntry[] @relation("ShareEntrySong")
  playlistEntries PlaylistSong[]
  tagAssignments SongTagAssignment[]
  createdAt DateTime @default(now())

  @@unique([userId, source, sourceUrl])
  @@index([playlistId])
  @@index([source])
  @@index([createdAt])
  @@index([title])
  @@index([artist])
  @@index([userId, createdAt])
  @@index([userId, playlistId])
  @@index([userId, albumId, discNumber, trackNumber])
  @@index([artistId])
  @@index([albumId])
  @@index([libraryId])
  @@index([userId, rating])
}

model User {
  id           Int      @id @default(autoincrement())
  username     String   @unique
  passwordHash String
  subsonicToken String?
  subsonicPasswordEnc String?
  authTokenVersion Int @default(0)
  role         UserRole @default(admin)
  disabledAt   DateTime?
  createdAt    DateTime @default(now())
  songs        Song[]
  playlists    Playlist[]
  downloadTasks DownloadTask[]
  downloadTaskEvents DownloadTaskEvent[]
  playbackSessions PlaybackSession[]
  libraries    Library[]
  artists      Artist[]
  albums       Album[]
  bookmarks    Bookmark[]
  shares       Share[]
  shareEntries ShareEntry[]
  smartPlaylists SmartPlaylist[]
  songTags     SongTag[]
}

model Playlist {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  createdAt DateTime @default(now())
  songs     Song[]
  entries   PlaylistSong[]
  downloadTasks DownloadTask[]
  sharedEntries ShareEntry[] @relation("ShareEntryPlaylist")

  @@unique([userId, name])
}

model SmartPlaylist {
  id          Int      @id @default(autoincrement())
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  ruleJson    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, name])
  @@index([userId, updatedAt])
}

model PlaylistSong {
  id         Int      @id @default(autoincrement())
  playlistId Int
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  songId     Int
  song       Song     @relation(fields: [songId], references: [id], onDelete: Cascade)
  position   Int
  createdAt  DateTime @default(now())

  @@unique([playlistId, position])
  @@index([playlistId, songId])
}

model DownloadTask {
  id                  Int                 @id @default(autoincrement())
  userId              Int
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  source              String
  sourceUrl           String
  format              String
  quality             String?
  bestAudioPreference String?
  playlistId          Int?
  playlist            Playlist?           @relation(fields: [playlistId], references: [id], onDelete: SetNull)
  status              String              @default("queued")
  playlistTitle       String?
  isPlaylist          Boolean             @default(false)
  totalItems          Int?
  processedItems      Int                 @default(0)
  successfulItems     Int                 @default(0)
  failedItems         Int                 @default(0)
  errorMessage        String?
  workerPid           Int?
  heartbeatAt         DateTime?
  createdAt           DateTime            @default(now())
  startedAt           DateTime?
  completedAt         DateTime?
  updatedAt           DateTime            @updatedAt
  songs               Song[]
  events              DownloadTaskEvent[]

  @@index([status])
  @@index([createdAt])
  @@index([userId, status, createdAt])
}

model DownloadTaskEvent {
  id        Int          @id @default(autoincrement())
  userId    Int
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  taskId    Int
  task      DownloadTask @relation(fields: [taskId], references: [id], onDelete: Cascade)
  level     String
  message   String
  payload   String?
  createdAt DateTime     @default(now())

  @@index([taskId])
  @@index([userId, taskId, createdAt])
}

model PlaybackSession {
  id            Int                 @id @default(autoincrement())
  userId        Int
  user          User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceId      String
  currentSongId Int?
  currentSong   Song?               @relation("CurrentPlaybackSong", fields: [currentSongId], references: [id], onDelete: SetNull)
  positionSec   Float               @default(0)
  isPlaying     Boolean             @default(false)
  repeatMode    String              @default("off")
  shuffle       Boolean             @default(false)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  queueItems    PlaybackQueueItem[]

  @@unique([userId, deviceId])
  @@index([userId, updatedAt])
}

model PlaybackQueueItem {
  id         Int             @id @default(autoincrement())
  sessionId  Int
  session    PlaybackSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  songId     Int
  song       Song            @relation("QueueSong", fields: [songId], references: [id], onDelete: Cascade)
  sortOrder  Int
  createdAt  DateTime        @default(now())

  @@unique([sessionId, sortOrder])
  @@index([sessionId, songId])
}

model Artist {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  sortName  String?
  mbid      String?
  createdAt DateTime @default(now())
  albums    Album[]
  songs     Song[]

  @@unique([userId, name])
  @@index([name])
}

model Album {
  id          Int      @id @default(autoincrement())
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  title       String
  artistId    Int?
  artist      Artist?  @relation(fields: [artistId], references: [id], onDelete: SetNull)
  albumArtist String?
  year        Int?
  coverPath   String?
  createdAt   DateTime @default(now())
  songs       Song[]
  sharedEntries ShareEntry[] @relation("ShareEntryAlbum")

  @@unique([userId, title, albumArtist])
  @@index([artistId, title])
}

model Bookmark {
  id          Int      @id @default(autoincrement())
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  songId      Int
  song        Song     @relation(fields: [songId], references: [id], onDelete: Cascade)
  positionSec Float    @default(0)
  comment     String?
  createdAt   DateTime @default(now())
  changedAt   DateTime @updatedAt

  @@index([userId, changedAt])
  @@index([songId])
}

enum ShareEntryType {
  song
  album
  playlist
}

model Share {
  id          Int      @id @default(autoincrement())
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token       String   @unique
  description String?
  expiresAt   DateTime?
  lastVisited DateTime?
  visitCount  Int      @default(0)
  createdAt   DateTime @default(now())
  entries     ShareEntry[]

  @@index([userId, createdAt])
}

model ShareEntry {
  id         Int            @id @default(autoincrement())
  userId     Int
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  shareId    Int
  share      Share          @relation(fields: [shareId], references: [id], onDelete: Cascade)
  type       ShareEntryType
  songId     Int?
  song       Song?          @relation("ShareEntrySong", fields: [songId], references: [id], onDelete: Cascade)
  albumId    Int?
  album      Album?         @relation("ShareEntryAlbum", fields: [albumId], references: [id], onDelete: Cascade)
  playlistId Int?
  playlist   Playlist?      @relation("ShareEntryPlaylist", fields: [playlistId], references: [id], onDelete: Cascade)
  createdAt  DateTime       @default(now())

  @@index([userId, shareId])
  @@index([songId])
  @@index([albumId])
  @@index([playlistId])
}

model Library {
  id          Int       @id @default(autoincrement())
  userId      Int
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  createdAt   DateTime  @default(now())
  songs       Song[]
  paths       LibraryPath[]
  scanRuns    LibraryScanRun[]

  @@unique([userId, name])
}

model LibraryPath {
  id            Int      @id @default(autoincrement())
  libraryId     Int
  library       Library  @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  path          String
  enabled       Boolean  @default(true)
  lastScannedAt DateTime?
  createdAt     DateTime @default(now())

  @@unique([libraryId, path])
}

model LibraryScanRun {
  id         Int      @id @default(autoincrement())
  libraryId  Int
  library    Library  @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  status     String   @default("running")
  startedAt  DateTime @default(now())
  finishedAt DateTime?
  statsJson  String?
  error      String?

  @@index([libraryId, startedAt])
}

model SongTag {
  id          Int      @id @default(autoincrement())
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  color       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  songs       SongTagAssignment[]

  @@unique([userId, name])
  @@index([userId, updatedAt])
}

model SongTagAssignment {
  id        Int      @id @default(autoincrement())
  songId    Int
  song      Song     @relation(fields: [songId], references: [id], onDelete: Cascade)
  tagId     Int
  tag       SongTag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([songId, tagId])
  @@index([tagId, createdAt])
}

model RateLimitEvent {
  id        Int      @id @default(autoincrement())
  key       String
  createdAt DateTime @default(now())

  @@index([key, createdAt])
  @@index([createdAt])
}
